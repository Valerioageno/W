{"version":3,"file":"W.js","sources":["../src/index.js","../src/core/index.js"],"sourcesContent":["// import * as Models from './models/index'\nimport * as Renderer from './core/index.js'\n\nexport default {Renderer: Renderer.default}","// WebGL framework\n// ===============\nimport baseVertex from '../shaders/baseVertex.glsl'\nimport baseFragment from '../shaders/baseFragment.glsl'\n\nexport default class Renderer {\n\n  constructor(options) {\n    this.debug = options.debug; // Enable shader/program compilation logs (optional)\n    this.reset(options.canvas)\n    // List of 3D models that can be rendered by the framework\n    // (See the end of the file for built-in models: plane, billboard, cube, pyramid...)\n    this.models = {};\n    // List of renderers\n    // (see the end of the file for built-in renderers: triangles, lines...)\n    this.renderers = {};\n  }\n  // Reset the framework\n  // param: a <canvas> element\n  reset(canvas){\n    // Globals\n    this.canvas = canvas;    // canvas element\n    this.objs = 0;           // Object counter\n    this.current = {};       // Objects current states\n    this.next = {};          // Objects next states\n    this.textures = {};      // Textures list\n\n    // WebGL context\n    this.gl = this.canvas.getContext('webgl2');\n    \n    // Default blending method for transparent objects\n    this.gl.blendFunc(770 /* SRC_ALPHA */, 771 /* ONE_MINUS_SRC_ALPHA */);\n    \n    // Enable texture 0\n    this.gl.activeTexture(33984 /* TEXTURE0 */);\n\n    // Create a WebGL program\n    this.program = this.gl.createProgram();\n    \n    // Hide polygons back-faces (optional)\n    //W.gl.enable(2884 /* CULL_FACE */);\n    \n    // Create a Vertex shader\n    // (this GLSL program is called for every vertex of the scene)\n    this.gl.shaderSource(\n      \n      this.t = this.gl.createShader(35633 /* VERTEX_SHADER */),\n      \n      baseVertex\n    );\n    \n    // Compile the Vertex shader and attach it to the program\n    this.gl.compileShader(this.t);\n    this.gl.attachShader(this.program, this.t);\n    if(this.debug) console.log('vertex shader:', this.gl.getShaderInfoLog(this.t) || 'OK');\n    \n    // Create a Fragment shader\n    // (This GLSL program is called for every fragment (pixel) of the scene)\n    this.gl.shaderSource(\n\n      this.t = this.gl.createShader(35632 /* FRAGMENT_SHADER */),\n      \n      baseFragment\n    );\n    \n    // Compile the Fragment shader and attach it to the program\n    this.gl.compileShader(this.t);\n    this.gl.attachShader(this.program, this.t);\n    if(this.debug) console.log('fragment shader:', this.gl.getShaderInfoLog(this.t) || 'OK');\n    \n    // Compile the program\n    this.gl.linkProgram(this.program);\n    this.gl.useProgram(this.program);\n    if(this.debug) console.log('program:', this.gl.getProgramInfoLog(this.program) || 'OK');\n    \n    // Set the scene's background color (RGBA)\n    this.gl.clearColor(1, 1, 1, 1);\n    \n    // Shortcut to set the clear color\n    this.clearColor = c => this.gl.clearColor(...this.col(c));\n    this.clearColor(\"ffff\");\n    \n    // Enable fragments depth sorting\n    // (the fragments of close objects will automatically overlap the fragments of further objects)\n    this.gl.enable(2929 /* DEPTH_TEST */);\n    \n    // When everything is loaded: set default light / camera, and draw the scene\n    this.light({y: -1});\n    this.camera({fov: 30});\n    this.draw();\n  };\n\n  // Set a state to an object\n  setState(state, type, texture, i, normal = [], A, B, C, Ai, Bi, Ci, AB, BC) {\n\n    // Custom name or default name ('o' + auto-increment)\n    this.state = state\n    this.state.n ||= 'o' + this.objs++;\n    \n    // Size sets w, h and d at once (optional)\n    if(this.state.size) this.state.w = this.state.h = this.state.d = this.state.size;\n    \n    // If a new texture is provided, build it and save it in W.textures\n    if(this.state.t && this.state.t.width && !this.textures[this.state.t.id]){\n      this.texture = this.gl.createTexture();\n      this.gl.pixelStorei(37441 /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */, true);\n      this.gl.bindTexture(3553 /* TEXTURE_2D */, this.texture);\n      this.gl.pixelStorei(37440 /* UNPACK_FLIP_Y_WEBGL */, 1);\n      this.gl.texImage2D(3553 /* TEXTURE_2D */, 0, 6408 /* RGBA */, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, this.state.t);\n      this.gl.generateMipmap(3553 /* TEXTURE_2D */);\n      this.textures[this.state.t.id] = this.texture;\n    }\n    \n    // Save object's type,\n    // merge previous state (or default state) with the new state passed in parameter,\n    // and reset f (the animation timer)\n    this.state = {type, ...(this.current[this.state.n] = this.next[this.state.n] || {w:1, h:1, d:1, x:0, y:0, z:0, rx:0, ry:0, rz:0, b:'888', mode:4, mix: 0}), ...this.state, f:0};\n    \n    if(this.model) {\n      // Build the model's vertices buffer if it doesn't exist yet\n      if(this.models[this.state.type]?.vertices && !this.models?.[this.state.type].verticesBuffer){\n        this.gl.bindBuffer(34962 /* ARRAY_BUFFER */, this.models[this.state.type].verticesBuffer = this.gl.createBuffer());\n        this.gl.bufferData(34962 /* ARRAY_BUFFER */, new Float32Array(this.models[this.state.type].vertices), 35044 /*STATIC_DRAW*/); \n      }\n      \n      // Build the model's uv buffer (if any) if it doesn't exist yet\n      if(this.models[this.state.type]?.uv && !this.models[this.state.type].uvBuffer){\n        this.gl.bindBuffer(34962 /* ARRAY_BUFFER */, this.models[this.state.type].uvBuffer = this.gl.createBuffer());\n        this.gl.bufferData(34962 /* ARRAY_BUFFER */, new Float32Array(this.models[this.state.type].uv), 35044 /*STATIC_DRAW*/); \n      }\n      \n      // Build the model's index buffer (if any) and smooth normals if they don't exist yet\n      if(this.models[this.state.type]?.indices && !this.models[this.state.type].indicesBuffer){\n        this.gl.bindBuffer(34963 /* ELEMENT_ARRAY_BUFFER */, this.models[this.state.type].indicesBuffer = this.gl.createBuffer());\n        this.gl.bufferData(34963 /* ELEMENT_ARRAY_BUFFER */, new Uint16Array(this.models[state.type].indices), 35044 /* STATIC_DRAW */);\n        \n        // Compute smooth normals (optional)\n        if(!this.models[this.state.type].smoothNormals && this.smooth) this.smooth(this.state);\n        \n        // Make a buffer from the smooth normals (if any)\n        if(this.models[this.state.type].smoothNormals){\n          // Smooth normals buffer\n          this.gl.bindBuffer(34962 /* ARRAY_BUFFER */, this.models[this.state.type].smoothNormalsBuffer = this.gl.createBuffer());\n          this.gl.bufferData(34962 /* ARRAY_BUFFER */, new Float32Array(this.models[this.state.type].smoothNormals.flat()), 35044 /*STATIC_DRAW*/); \n        }\n      }\n    }\n    \n    // Set mix to 1 if no texture is set\n    if(!this.state.t){\n      this.state.mix = 1;\n    }\n\n    // set mix to 0 by default if a texture is set\n    else if(this.state.t && !this.state.mix){\n      this.state.mix = 0;\n    }\n    \n    // Save new state\n    this.next[this.state.n] = this.state;\n    \n    // Set fov if the camera's state contains it\n    if(this.state.fov){\n      this.perspective =     \n        new DOMMatrix([\n          1 / Math.tan(this.state.fov * .0175) / (this.canvas.width/this.canvas.height), 0, 0, 0, \n          0, 1 / Math.tan(this.state.fov * .0175), 0, 0, \n          0, 0, (999 + 1) * 1 / (1 - 999), -1,\n          0, 0, (2 * 1 * 999) * 1 / (1 - 999), 0\n        ]);\n    }\n  };\n  \n  // Draw the scene\n  draw(now = 0, dt, v, i, transparent = []) {\n\n    this.lastFrame ||= 0\n    // Loop and measure time delta between frames\n    this.dt = now - this.lastFrame;\n    \n    this.lastFrame = now;\n    \n    // Clear canvas\n    this.gl.clear(16640 /* W.gl.COLOR_BUFFER_BIT | W.gl.DEPTH_BUFFER_BIT */);\n    \n    // Create a matrix called v containing the current camera transformation\n    this.v = v\n    this.v = this.animation('camera');\n    \n    // Send it to the shaders as the Eye matrix\n    this.gl.uniformMatrix4fv(\n      this.gl.getUniformLocation(this.program, 'eye'),\n      false,\n      this.v.toFloat32Array()\n    );\n    \n    // Invert it to obtain the View matrix\n    this.v.invertSelf();\n\n    // Premultiply it with the Perspective matrix to obtain a Projection-View matrix\n    this.v.preMultiplySelf(this.perspective);\n    \n    // send it to the shaders as the pv matrix\n    this.gl.uniformMatrix4fv(\n      this.gl.getUniformLocation(this.program, 'pv'),\n      false,\n      this.v.toFloat32Array()\n    );\n    \n    // Transition the light's direction and send it to the shaders\n    this.gl.uniform3f(\n      this.gl.getUniformLocation(this.program, 'light'),\n      this.lerp('light','x'), this.lerp('light','y'), this.lerp('light','z')\n    );\n    \n    // Render all the objects in the scene\n    for(i in this.next){\n      \n      // Render the shapes with no texture and no transparency (RGB1 color)\n      if(!this.next[i].t && this.col(this.next[i].b)[3] == 1){\n        this.render(this.next[i], this.dt);\n      }\n      \n      // Add the objects with transparency (RGBA or texture) in an array\n      else {\n        this.transparent.push(this.next[i]);\n      }\n    }\n    \n    // Order transparent objects from back to front\n    transparent.sort((a, b) => {\n      // Return a value > 0 if b is closer to the camera than a\n      // Return a value < 0 if a is closer to the camera than b\n      return this.dist(b) - this.dist(a);\n    });\n\n    // Enable alpha plending\n    this.gl.enable(3042 /* BLEND */);\n    \n    // Render the objects\n    for(i in this.transparent){\n      this.render(this.transparent[i], this.dt);\n    }\n    \n    // Disable alpha blending for next frame\n    this.gl.disable(3042 /* BLEND */);\n\n    window.requestAnimationFrame(() => this.draw());\n  };\n\n  addModel(state, type, buffer) {\n    this.model[type] = buffer\n    this.setState(state, type)\n  }\n  \n  // Render an object\n  render(object, dt, buffer) {\n\n    this.object = object\n    // If the object has a texture\n    if(this.object.t) {\n\n      // Set the texture's target (2D or cubemap)\n      this.gl.bindTexture(3553 /* TEXTURE_2D */, this.textures[this.object.t.id]);\n\n      // Pass texture 0 to the sampler\n      this.gl.uniform1i(this.gl.getUniformLocation(this.program, 'sampler'), 0);\n    }\n\n    // If the object has an animation, increment its timer...\n    if(this.object.f < this.object.a) this.object.f += this.dt;\n    \n    // ...but don't let it go over the animation duration.\n    if(this.object.f > this.object.a) this.object.f = this.object.a;\n\n    // Compose the model matrix from lerped transformations\n    this.next[this.object.n].m = this.animation(this.object.n);\n\n    // If the object is in a group:\n    if(this.next[this.object.g]){\n\n      // premultiply the model matrix by the group's model matrix.\n      this.next[this.object.n].m.preMultiplySelf(this.next[this.object.g].M || this.next[this.object.g].m);\n    }\n    \n    // send the model matrix to the vertex shader\n    this.gl.uniformMatrix4fv(\n      this.gl.getUniformLocation(this.program, 'm'),\n      false,\n      (this.next[this.object.n].M || this.next[this.object.n].m).toFloat32Array()\n    );\n    \n    // send the inverse of the model matrix to the vertex shader\n    this.gl.uniformMatrix4fv(\n      this.gl.getUniformLocation(this.program, 'im'),\n      false,\n      (new DOMMatrix(this.next[this.object.n].M || this.next[this.object.n].m)).invertSelf().toFloat32Array()\n    );\n    \n    // Don't render invisible items (camera, light, groups)\n    if(!['camera','light','group'].includes(this.object.type)){\n      \n      // Set up the position buffer\n      this.gl.bindBuffer(34962 /* ARRAY_BUFFER */, this.models[this.object.type].verticesBuffer);\n      this.gl.vertexAttribPointer(this.buffer = this.gl.getAttribLocation(this.program, 'pos'), 3, 5126 /* FLOAT */, false, 0, 0)\n      this.gl.enableVertexAttribArray(this.buffer);\n      \n      // Set up the texture coordinatess buffer (if any)\n      if(this.models[this.object.type].uvBuffer){\n        this.gl.bindBuffer(34962 /* ARRAY_BUFFER */, this.models[this.object.type].uvBuffer);\n        this.gl.vertexAttribPointer(this.buffer = this.gl.getAttribLocation(this.program, 'uv'), 2, 5126 /* FLOAT */, false, 0, 0);\n        this.gl.enableVertexAttribArray(this.buffer);\n      }\n      \n      // Set the normals buffer\n      if(this.object.s && this.models[this.object.type].smoothNormalsBuffer){\n        this.gl.bindBuffer(34962 /* ARRAY_BUFFER */, this.models[this.object.type].smoothNormalsBuffer);\n        this.gl.vertexAttribPointer(this.buffer = this.gl.getAttribLocation(this.program, 'normal'), 3, 5126 /* FLOAT */, false, 0, 0);\n        this.gl.enableVertexAttribArray(this.buffer);\n      }\n      \n      // Other options: [smooth, shading enabled, ambient light, texture/color mix]\n      this.gl.uniform4f(\n\n        this.gl.getUniformLocation(this.program, 'o'), \n        \n        // Enable smooth shading if \"s\" is true\n        this.object.s,\n        \n        // Enable shading if in TRIANGLE* mode and object.ns disabled\n        ((this.object.mode > 3) || (this.gl[this.object.mode] > 3)) && !this.object.ns ? 1 : 0,\n        \n        // Ambient light\n        this.ambientLight || 0.2,\n        \n        // Texture/color mix (if a texture is present. 0: fully textured, 1: fully colored)\n        this.object.mix\n      );\n      \n      // If the object is a billboard: send a specific uniform to the shaders:\n      // [width, height, isBillboard = 1, 0]\n      this.gl.uniform4f(\n        this.gl.getUniformLocation(this.program, 'bb'),\n        \n        // Size\n        this.object.w,\n        this.object.h,               \n\n        // is a billboard\n        this.object.type == 'billboard',\n        \n        // Reserved\n        0\n      );\n      \n      // Set up the indices (if any)\n      if(this.models[this.object.type].indicesBuffer){\n        this.gl.bindBuffer(34963 /* ELEMENT_ARRAY_BUFFER */, this.models[this.object.type].indicesBuffer);\n      }\n      \n      // Use a renderer (custom / default)\n      if(this.object.r){\n        this.renderers[this.object.r](this.object);\n      }\n      else {\n        // Set the object's color\n        this.gl.vertexAttrib4fv(\n          this.gl.getAttribLocation(this.program, 'col'),\n          this.col(this.object.b)\n        );\n\n        // Draw\n        // Both indexed and unindexed models are supported.\n        // You can keep the \"drawElements\" only if all your models are indexed.\n        if(this.models[this.object.type].indicesBuffer){\n          this.gl.drawElements(+this.object.mode || this.gl[this.object.mode], this.models[this.object.type].indices.length, 5123 /* UNSIGNED_SHORT */, 0);\n        }\n        else {\n          this.gl.drawArrays(+this.object.mode || this.gl[this.object.mode], 0, this.models[this.object.type].vertices.length / 3);\n        }\n      }\n    }\n  }\n  // Helpers\n  // -------\n  \n  // Interpolate a property between two values\n  lerp(item, property){\n    return this.next[item]?.a\n    ? this.current[item][property] + (this.next[item][property] -  this.current[item][property]) * (this.next[item].f / this.next[item].a)\n    : this.next[item][property]\n  }\n  \n  // Transition an item\n  animation(item, m = new DOMMatrix) {\n    return this.next[item]\n    ? m\n      .translateSelf(this.lerp(item, 'x'), this.lerp(item, 'y'), this.lerp(item, 'z'))\n      .rotateSelf(this.lerp(item, 'rx'),this.lerp(item, 'ry'),this.lerp(item, 'rz'))\n      .scaleSelf(this.lerp(item, 'w'),this.lerp(item, 'h'),this.lerp(item, 'd'))\n    : m\n  }\n    \n  // Compute the distance squared between two objects (useful for sorting transparent items)\n  dist(a, b = this.next.camera){\n    return a?.m && b?.m ? (b.m.m41 - a.m.m41)**2 + (b.m.m42 - a.m.m42)**2 + (b.m.m43 - a.m.m43)**2 : 0\n  } \n  \n  // Set the ambient light level (0 to 1)\n  ambient(a){return this.ambientLight = a}\n  \n  // Convert an rgb/rgba hex string into a vec4\n  col(c){\n    c = c.replace(\"#\",\"\");\n    if(c.length < 5) return [...[...c].map(a => ('0x' + a) / 15), 1]; // rgb / rgba\n    else return [...c.match(/../g).map(a => ('0x' + a) / 255), 1]; // rrggbb / rrggbbaa\n  }\n  \n  // Add a new 3D model\n  add(name, objects){\n    this.models[name] = objects;\n    this[name] = settings => this.setState(settings, name);\n  }\n  \n  // Built-in objects\n  // ----------------\n  \n  group(t) {return this.setState(t, 'group')} \n  \n  move(t, delay) {\n    setTimeout(()=>{ this.setState(t) }, delay || 1)\n  }\n  \n  delete(t, delay) {\n    setTimeout(()=>{ delete this.next[t.n] }, delay || 1)\n  }\n  \n  camera(t, delay){\n    setTimeout(()=>{ this.setState(t, t.n = 'camera') }, delay || 1)\n  }\n    \n  light(t, delay) {\n    delay ? setTimeout(()=>{ this.setState(t, t.n = 'light') }, delay) : this.setState(t, t.n = 'light')\n  }\n};"],"names":["Renderer","constructor","options","debug","reset","canvas","models","renderers","objs","current","next","textures","gl","this","getContext","blendFunc","activeTexture","program","createProgram","shaderSource","t","createShader","compileShader","attachShader","console","log","getShaderInfoLog","linkProgram","useProgram","getProgramInfoLog","clearColor","c","col","enable","light","y","camera","fov","draw","setState","state","type","normal","Math","tan","n","size","w","h","d","width","id","texture","createTexture","pixelStorei","bindTexture","texImage2D","generateMipmap","x","z","rx","ry","rz","b","mode","mix","f","model","vertices","verticesBuffer","bindBuffer","createBuffer","bufferData","Float32Array","uv","uvBuffer","indices","indicesBuffer","Uint16Array","smoothNormals","smooth","smoothNormalsBuffer","flat","perspective","DOMMatrix","height","now","dt","v","i","transparent","lastFrame","clear","animation","uniformMatrix4fv","getUniformLocation","toFloat32Array","invertSelf","preMultiplySelf","uniform3f","lerp","push","render","sort","a","dist","disable","window","requestAnimationFrame","addModel","buffer","object","uniform1i","m","g","M","includes","vertexAttribPointer","getAttribLocation","enableVertexAttribArray","s","uniform4f","ns","ambientLight","r","vertexAttrib4fv","drawElements","length","drawArrays","item","property","translateSelf","rotateSelf","scaleSelf","m41","m42","m43","ambient","replace","map","match","add","name","objects","settings","group","move","delay","setTimeout","delete"],"mappings":"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"}