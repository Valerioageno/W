if((vertices = W.models[state.type]?.vertices) && !W.models?.[state.type]?.normals){
  W.models[state.type].normals = {};
  W.models[state.type].smoothNormals = {};
  for(i = 0; i < vertices.length; i += 9){

    W.models[state.type].smoothNormals[A = vertices[i] + "_" + vertices[i+1] + "_" + vertices[i+2]] ||= [0,0,0];
    W.models[state.type].smoothNormals[B = vertices[i+3] + "_" + vertices[i+4] + "_" + vertices[i+5]] ||= [0,0,0];
    W.models[state.type].smoothNormals[C = vertices[i+6] + "_" + vertices[i+7] + "_" + vertices[i+8]] ||= [0,0,0];
    
    // Create vectors from 2 edges of each face if clockwise order
    AB = [vertices[i+3] - vertices[i], vertices[i+4] - vertices[i+1], vertices[i+5] - vertices[i+2]];
    BC = [vertices[i+6] - vertices[i+3], vertices[i+7] - vertices[i+4], vertices[i+8] - vertices[i+5]];
    
    // Compute the face normal (cross product of AB and BC)
    // By default, A, B, C are in counter-clockwise order so the cross product points outside
    W.models[state.type].smoothNormals[A][0] += (AB[1] * BC[2] - AB[2] * BC[1]);
    W.models[state.type].smoothNormals[A][1] += (AB[2] * BC[0] - AB[0] * BC[2]);
    W.models[state.type].smoothNormals[A][2] += (AB[0] * BC[1] - AB[1] * BC[0]);
    
    W.models[state.type].smoothNormals[B][0] += (AB[1] * BC[2] - AB[2] * BC[1]);
    W.models[state.type].smoothNormals[B][1] += (AB[2] * BC[0] - AB[0] * BC[2]);
    W.models[state.type].smoothNormals[B][2] += (AB[0] * BC[1] - AB[1] * BC[0]);
    
    W.models[state.type].smoothNormals[C][0] += (AB[1] * BC[2] - AB[2] * BC[1]);
    W.models[state.type].smoothNormals[C][1] += (AB[2] * BC[0] - AB[0] * BC[2]);
    W.models[state.type].smoothNormals[C][2] += (AB[0] * BC[1] - AB[1] * BC[0]);
    
    W.W.gl.bindBuffer(34962 /* ARRAY_BUFFER */, W.models[state.type].normalsBuffer = W.W.gl.createBuffer());
    W.W.gl.bufferData(34962 /* ARRAY_BUFFER */, new Float32Array(W.models[state.type].normals), 35044 /*STATIC_DRAW*/);
  }
}